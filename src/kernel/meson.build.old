# Kernel Build Configuration
# ==========================
# The main NeoOS kernel

message('Building kernel...')

# Path to ISR generator script in project root scripts folder
isr_generator_script = join_paths(meson.project_source_root(), '/scripts/generate_isr.py')

# Explicitly check it's the only one being used
if not fs.exists('arch/i686/isrs_gen.inc')
    isrs_gen_inc = custom_target(
        'isrs_gen.inc',
        input: '../../scripts/generate_isr.py',
        output: 'isrs_gen.inc',
        command: [python3, '@INPUT@', '-o', '@OUTPUT@'],
        console: true,
        build_by_default: true,
    )

endif

# === Configuration ===
kernel_dir = meson.current_source_dir()
fs = import('fs')

# === Auto-discover source files ===
# Find all C source files in kernel directories
kernel_c_sources = []
kernel_c_dirs = [
    'arch/generic',
    'arch/i686',
    'arch/i686/interrupts',
    'arch/i686/pic',
    'hal',
    '.', # Current directory
]

# Use Python to find C files
foreach dir : kernel_c_dirs
    full_dir = kernel_dir / dir
    if fs.exists(full_dir)
        find_c_result = run_command(
            'python3',
            '-c', 'import glob; print("\\n".join(glob.glob("'
            + full_dir
            + '/*.c")))',
            capture: true,
            check: false,
        )
        if find_c_result.returncode() == 0
            c_files = find_c_result.stdout().strip().split('\n')
            foreach c_file : c_files
                if c_file != '' and fs.exists(c_file)
                    kernel_c_sources += files(c_file)
                endif
            endforeach
        endif
    endif
endforeach

message('Found @0@ C source files for kernel'.format(kernel_c_sources.length()))

# Find all assembly source files (excluding CRT files)
kernel_asm_sources = []
kernel_asm_dirs = [
    'arch/i686',
    'arch/i686/interrupts',
    '.',
]

foreach dir : kernel_asm_dirs
    full_dir = kernel_dir / dir
    if fs.exists(full_dir)
        find_asm_result = run_command(
            'python3',
            '-c', 'import glob; print("\\n".join(glob.glob("'
            + full_dir
            + '/*.asm")))',
            capture: true,
            check: false,
        )
        if find_asm_result.returncode() == 0
            asm_files = find_asm_result.stdout().strip().split('\n')
            foreach asm_file : asm_files
                if asm_file != '' and fs.exists(asm_file)
                    filename = fs.name(asm_file)
                    if filename != 'crti.asm' and filename != 'crtn.asm'
                        kernel_asm_sources += files(asm_file)
                    endif
                endif
            endforeach
        endif
    endif
endforeach

message(
    'Found @0@ assembly source files for kernel'.format(kernel_asm_sources.length()),
)

# === CRT Files (Critical ordering) ===
crti_asm = files('crti.asm')[0]
crtn_asm = files('crtn.asm')[0]

# Verify CRT files exist
if not fs.exists(crti_asm.full_path())
    error('crti.asm not found in kernel directory')
endif
if not fs.exists(crtn_asm.full_path())
    error('crtn.asm not found in kernel directory')
endif

# === Build Assembly Objects ===
# Build CRT objects first
crti_obj = custom_target(
    'kernel_crti_obj',
    input: crti_asm,
    output: 'crti.o',
    command: [nasm, '-f', 'elf32', '-o', '@OUTPUT@', '@INPUT@'],
    install: false,
)

crtn_obj = custom_target(
    'kernel_crtn_obj',
    input: crtn_asm,
    output: 'crtn.o',
    command: [nasm, '-f', 'elf32', '-o', '@OUTPUT@', '@INPUT@'],
    install: false,
)

# Build other assembly objects
kernel_asm_objects = []
foreach asm_file : kernel_asm_sources
    asm_name = fs.name(asm_file.full_path()).split('.')[0] + '_kernel'
    asm_obj = custom_target(
        'kernel_' + asm_name + '_obj',
        input: asm_file,
        output: asm_name + '.o',
        command: [
            nasm,
            '-I', meson.project_source_root() + '/src/kernel/arch/i686',
            '-f', 'elf32',
            '-o', '@OUTPUT@',
            '@INPUT@',
        ],
        install: false,
    )

    kernel_asm_objects += [asm_obj]
endforeach

# === Detect libgcc for CRT objects ===
# Use project toolchain instead of system toolchain
toolchain_base = meson.project_source_root() / 'toolchain' / 'i686-elf'
libgcc_dir = toolchain_base / 'lib' / 'gcc' / 'i686-elf' / '15.1.0'
toolchain_include = libgcc_dir / 'include'

crtbegin_obj = libgcc_dir / 'crtbegin.o'
crtend_obj = libgcc_dir / 'crtend.o'

if fs.exists(crtbegin_obj) and fs.exists(crtend_obj)
    message('Found toolchain CRT objects:')
    message('  crtbegin.o: ' + crtbegin_obj)
    message('  crtend.o: ' + crtend_obj)
else
    warning('Toolchain CRT objects not found - linking may fail')
    warning('Expected at: ' + libgcc_dir)
    crtbegin_obj = ''
    crtend_obj = ''
endif

# === Linker Configuration ===
kernel_linker_script = kernel_dir / 'linker.ld'

# Verify linker script exists
if not fs.exists(kernel_linker_script)
    error('Kernel linker script not found: ' + kernel_linker_script)
endif

kernel_link_args = [
    '-T', kernel_linker_script,
    '-Map', meson.current_build_dir() / 'kernel.map',
    '-nostdlib',
    '-static',
]

# === Kernel-specific Compile Flags ===
kernel_c_args = cflags + [
    '-fno-pie', # Disable position independent executable
    '-static', # Static linking
    '-fno-omit-frame-pointer', # Keep frame pointers for debugging
    '-mno-red-zone', # Don't use red zone (x86_64 feature, but good practice)
]

# === Build Kernel ELF with Proper CRT Ordering ===
kernel_objects_and_libs = kernel_asm_objects + [isrs_gen_inc]

# Build the kernel executable with proper CRT ordering
kernel_elf_sources = kernel_c_sources + kernel_objects_and_libs

kernel_elf = executable(
    'kernel',
    kernel_elf_sources,
    objects: [crti_obj]
    + (crtbegin_obj != '' ? [crtbegin_obj] : [])
    + (crtend_obj != '' ? [crtend_obj] : [])
    + [crtn_obj],
    c_args: cflags + ['-I' + toolchain_include, '-I.'],
    cpp_args: cxxflags + ['-I' + toolchain_include, '-I.'],
    link_args: kernel_link_args,
    dependencies: [libcore_dep],
    install: false,
    native: false,
    name_suffix: 'elf', # Explicit ELF suffix for freestanding target
)

# === Create Stripped Kernel (for release) ===
kernel_stripped_elf = custom_target(
    'kernel-stripped.elf',
    input: kernel_elf,
    output: 'kernel-stripped.elf',
    command: [
        strip_prog,
        '--strip-debug',
        '--strip-unneeded',
        '-o', '@OUTPUT@',
        '@INPUT@',
    ],
    install: false,
)

message('Kernel build configured successfully')